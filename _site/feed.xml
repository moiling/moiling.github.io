<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MOI</title>
    <description>THE MOI'S WORLD</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 14 Jun 2019 17:59:19 +0000</pubDate>
    <lastBuildDate>Fri, 14 Jun 2019 17:59:19 +0000</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Reimplementation of Information Flow Matting</title>
        <description>&lt;h1 id=&quot;information-flow-matting&quot;&gt;Information Flow Matting&lt;/h1&gt;

&lt;p&gt;来除草了，最近都在做一些杂事，就记一篇最近复现论文的工作和一些思考吧。其实是实验报告……最近没太多时间用于记录，需要学习的内容实在太多了，等有一定积累的时候再来吧！不然记录的东西都是错误的也没什么价值。&lt;/p&gt;

&lt;h3 id=&quot;实验目的&quot;&gt;实验目的&lt;/h3&gt;

&lt;p&gt;复现 Aksoy 等人在论文《Designing Effective Inter-Pixel Information Flow for Natural Image Matting》中提出的基于传播的抠图算法。&lt;/p&gt;

&lt;h3 id=&quot;实验原理&quot;&gt;实验原理&lt;/h3&gt;

&lt;p&gt;基于传播的抠图方法依据像素之间颜色和空间的相近性，将透明度从已知区域传播到未知区域。基于传播的抠图方法有局部和非局部两种。局部方法为每个未知点设置一个以它为中心的窗口，信息只通过该点对应的窗口中的点传播。非局部方法则通过未知点的颜色和空间信息寻 找几个邻近点，信息通过这几个邻近点传播，不限于局部窗口内。&lt;/p&gt;

&lt;p&gt;该论文使用线性表达式将局部方法与非局部方法结合起来，其中局部方法使用了 Close-Form Matting 的算法，非局部方法则由作者设计，由三部分组成:颜色混合信息流、已知区域到未 知区域信息流、未知区域内部信息流。算法流程图如下图所示。其中各个信息流之间主要的差异在于邻近点的搜索空间不同，颜色混合信息流从全图中搜索，已知区域到未知区域信息流只从已知区域中搜索，未知区域内部信息流只从未知区域中搜索。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/IFM-20190610/01.png&quot; alt=&quot;img_1 算法流程图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大致计算流程如下，首先在每个信息流中使用 K 邻近法(KNN)搜索邻近点，其中搜索使用的特征向量如表 1 所示。然后使用局部线形嵌入方法(LLE)求解公式(1)得到权重。最后将每个信息流线性组合成公式(2)，并使用预条件共轭梯度法(PCG)求出透明度。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(1): \underset{w_{p, q}}{\arg \min }\left\|\boldsymbol{c}_{\boldsymbol{p}}-\sum_{q \in \mathcal{N}_{p}} w_{p, q} \boldsymbol{c}_{\boldsymbol{q}}\right\|^{2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(2): E_{1}=E_{C M}+\sigma_{\mathcal{k} \mathcal{u}} E_{\mathcal{k} \mathcal{u}}+\sigma_{\mathcal{u} \mathcal{u}} E_{\mathcal{u} \mathcal{u}}+\sigma_{L} E_{L}+\lambda E_{\mathcal{T}}&lt;/script&gt;

&lt;p&gt;公式(1)中&lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;为点&lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;的 RGB 颜色向量，&lt;script type=&quot;math/tex&quot;&gt;\mathcal{N}&lt;/script&gt;为点&lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;通过 KNN 获取的邻近点集合，该公式的作用为计算出点&lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;邻近点的权重，这些权重可以使得邻近点加权组合成的颜色与点&lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;的颜色相近，从而使用这些权重与邻近点的透明度计算出点&lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;的透明度。公式(2)为每个信息流的线性组合，其 中&lt;script type=&quot;math/tex&quot;&gt;\sigma_{\mathcal{k} \mathcal{u}}&lt;/script&gt;、&lt;script type=&quot;math/tex&quot;&gt;\sigma_{\mathcal{u} \mathcal{u}}&lt;/script&gt;、&lt;script type=&quot;math/tex&quot;&gt;\sigma_{L}&lt;/script&gt;、&lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;为参数，其取值下表所示，&lt;script type=&quot;math/tex&quot;&gt;E_{\mathcal{T}}&lt;/script&gt;是为了保持三分图中的前景和背景信息不 被影响而附加的公式，&lt;script type=&quot;math/tex&quot;&gt;E_{C M}&lt;/script&gt;如公式(3)所示，其余公式大同小异，不再赘述。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(3): E_{C M}=\sum_{p \in U}\left(\alpha_{p}-\sum_{q \in N_{p}^{C M}} w_{p, q}^{C M} \alpha_{q}\right)^{2}&lt;/script&gt;

&lt;p&gt;公式(3)中&lt;script type=&quot;math/tex&quot;&gt;U&lt;/script&gt;为未知区域的点集，该公式通过邻近点的权重和透明度计算未知点的透明度，之所以计算差值是因为论文中不止使用一种评估透明度的方法，如公式(2)所示，将这些评估的差值线性组合起来，使得总差值最小，从而计算最终的透明度。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;参数名&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;参数值&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;颜色混合信息流的搜索特征&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[𝑟, 𝑔, 𝑏, 𝑥, 𝑦]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;已知到未知信息流的搜索特征&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[𝑟, 𝑔, 𝑏, 𝑥 × 10, 𝑦 × 10]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;未知内部信息流的搜索特征&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[𝑟, 𝑔, 𝑏, 𝑥/20, y/20]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;颜色混合信息流的邻近点个数 &lt;script type=&quot;math/tex&quot;&gt;K_{C M}&lt;/script&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;已知到未知信息流的邻近点个数 &lt;script type=&quot;math/tex&quot;&gt;K_{\mathcal{k} \mathcal{u}}&lt;/script&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;未知内部信息流的邻近点个数 &lt;script type=&quot;math/tex&quot;&gt;K_{\mathcal{u} \mathcal{u}}&lt;/script&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;已知到未知信息流的混合系数 &lt;script type=&quot;math/tex&quot;&gt;\sigma_{\mathcal{k} \mathcal{u}}&lt;/script&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.05&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;未知内部信息流的混合系数 &lt;script type=&quot;math/tex&quot;&gt;\sigma_{\mathcal{u} \mathcal{u}}&lt;/script&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.01&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;局部信息流的混合系数 &lt;script type=&quot;math/tex&quot;&gt;\sigma_{L}&lt;/script&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;保持三分图已知信息的混合系数 &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;实验步骤&quot;&gt;实验步骤&lt;/h3&gt;

&lt;p&gt;1、寻找算法库
由于该论文使用了很多已有的算法，且并没做详细说明，故在复现的开始先寻找提供了这些算法的第三方库。其中 KNN 算法使用了 SKLERAN 库中的 neighbors 模块，LLE 算法使用了 NUMPY 库中的 Linear Algebra Tools 模块，PCG 使用了 SCIPY 库中的 sparse 模块，局部信息流使用了一个开源的 Close-Form Matting 中的方法。&lt;/p&gt;

&lt;p&gt;2、实现非局部方法中的邻近点搜索功能
由于 KNN 算法使用的是第三方库，所以该功能实现起来很简单。输入搜索区域和被搜索区域，用 KNN 算法搜索出邻近点即可。这里要注意的是 KNN 搜索的时候如果搜索区域和被搜索区域有重叠，那么最近的点一定是自身，需要将自身的点排除。&lt;/p&gt;

&lt;p&gt;3、实现计算权重的方法
直接使用第三方的 LLE 算法计算公式(1)即可。&lt;/p&gt;

&lt;p&gt;4、实现各个信息流
整个算法由四个信息流和最终的求解组成，其中三个非局部信息流的实现过程相似。首先读取图片和三分图的信息、加载算法需要的参数，然后通过三分图计算出背景区域、前景区域和未知区域，将这些区域和对应的参数交给邻近点搜索算法计算出临近点，最后通过计算权重的算法计算出每个信息流的权重即可。其中未知区域内部信息流的权重不是通过公式(1)计算 的，而是论文中的另一个简单公式，不需要使用 LLE 算法。其中局部信息流直接使用了开源的 Close-Form Matting 算法。&lt;/p&gt;

&lt;p&gt;5、实现透明度的求解
将所有信息流求得的权重按照公式(2)组合起来，使用第三方库的 PCG 算法进行求解。&lt;/p&gt;

&lt;h3 id=&quot;实验结果与分析&quot;&gt;实验结果与分析&lt;/h3&gt;

&lt;p&gt;1、分步结果&lt;/p&gt;

&lt;p&gt;分步结果的示意图如下图所示，其中(a)为执行颜色混合信息流的结果，(b)为接着执行已知区域到未知区域信息流的结果，(c)为接着执行未知点内部信息流的结果，(d)为接着执行局部信息流的结果。其中蓝色框和黄色框的区域分别为结果局部放大的图像。&lt;/p&gt;

&lt;p&gt;通过该结果可以看出，颜色混合信息流可以基本获取到未知点的透明度，该结果可以保留大量的孔洞特征，图(a)的黄色框中叶子缝隙保留完整。但是距离背景近的未知点可能整块都被错误判断为背景，图(a)的蓝色框中许多叶子全都被判断为背景，这是由于这些叶子内 部颜色相近，颜色混合信息流的邻近点可能全取自未知点，导致这些叶子判断错误。&lt;/p&gt;

&lt;p&gt;已知区域到未知区域信息流的结果弥补了颜色混合信息流的缺陷，由于邻近点都是从已知区域中选取的，所以图(b)的蓝色框中的叶子被正确判断为前景。但由于该信息流的空间约束很大，造成前景内部的孔洞特征消失，从图(b)的黄色框中可以看出，原本叶子间的缝隙 完全消失了。&lt;/p&gt;

&lt;p&gt;未知区域内部信息流由于空间约束条件小，可以从很远的地方寻找颜色相近的邻近点，从而弥 补已知区域到未知区域信息流照成孔洞特征消失的缺陷，从图 2(c)的黄色框中可以看出，叶子间的缝隙被复原了一些。但是边缘的噪声也随之增加了，图 2(c)的蓝色框中叶子边缘 的噪声更多了。所以未知区域内部信息流并不一定可以使结果变得更好，要做取舍。&lt;/p&gt;

&lt;p&gt;局部信息流由于是在局部窗口中传播，所以可以使得最终结果变得更加平滑。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/IFM-20190610/02.png&quot; alt=&quot;img_2 分步结果示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、运行时间&lt;/p&gt;

&lt;p&gt;运行时间如下图所示，其中 Python 为本实验复现的结果，MATLAB 为作者提供源码的结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/IFM-20190610/03.png&quot; alt=&quot;img_3 运行时间比较&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看出复现结果与作者提供的结果相差无几。除了 net 的测试集以外均可在 50s 左右得出 结果，与论文中描述一致。&lt;/p&gt;

&lt;p&gt;3、与作者提供源码结果的差异&lt;/p&gt;

&lt;p&gt;由于论文中没有三分图预处理的具体方法，故只将未作预处理的结果进行比较。两种之间没有肉眼可见的区别，但是还是有部分像素差，主要原因是因为 PCG 算法的差异导致的，目前没有 找到计算结果和 MATLAB 完全一致的 Python 替代算法。但是其结果在 alphamatting.com 上测试并没有明显差别，其中 MSE 的差别如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/IFM-20190610/04.png&quot; alt=&quot;img_4 MSE比较&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在对比实验时也将每一步算出来的权重进行了比较，没有差异，故本实验已经将论文中所提到 的算法流程进行了复现。&lt;/p&gt;

&lt;p&gt;4、与原文结果的差异&lt;/p&gt;

&lt;p&gt;作者提供的源码与论文中的结果存在一定差距，但作者强调该源码为论文的复现版本，不提供论文的原始代码，可以依照该复现版本进行对比实验和改进。故将两者进行了简单的比较，如下图所示，其中(a)为实验结果、(b)为论文结果、(c)修改参数的结果。通过对比实验结果与论文结果可以发现，论文结果保留了更多孔洞的信息，如图黄色框。在实验分步运行阶段可知，保留孔洞信息主要通过颜色混合信息流和未知区域内部信息流完成。故将对应过程 的系数增加，得到图(c)的结果。从结果可以发现，黄框部分的孔洞细节更接近论文结 果，但是蓝色框部分的噪声也随之增加，这部分在上文也论述过原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/IFM-20190610/05.png&quot; alt=&quot;img_5 与论文结果的差异比较&quot; /&gt;&lt;/p&gt;

&lt;p&gt;并非所有情况都可以通过增加未知区域信息流的权重使结果变好，如下图展示的是其中一个测试样本，图中黑色部分表示实验结果和原文结果的差异部分，图(a)为实验结果，(b)为修改参数的结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/IFM-20190610/06.png&quot; alt=&quot;img_6 通过减小未知区域内部信息流权重降低周围噪声示意图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于该样本的前景为一个菠萝，没有孔洞信息，这样未知区域信息流的操作使得周围噪声变多的坏处要远大于解决孔洞问题所带来的好处。故尝试降低未知区域信息流的权重，得到图(b)的结果，从结果可以发现，周围的噪声明显变少了。&lt;/p&gt;

&lt;p&gt;所以我认为论文中的结果可能根据样本的不同调节了参数，选择了每个样本最好的结果放到测 试集上进行测试。或者是作者隐藏了可以判断是否存在大量孔洞或其他情况的方法，可以自动调节参数。&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2019/06/10/IFM/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/10/IFM/</guid>
        
        <category>CV</category>
        
        
      </item>
    
      <item>
        <title>CRP</title>
        <description>&lt;h1 id=&quot;crp&quot;&gt;CRP&lt;/h1&gt;

&lt;p&gt;Carnival Route Programming - 游乐园路径规划&lt;/p&gt;

&lt;h3 id=&quot;问题描述&quot;&gt;问题描述&lt;/h3&gt;

&lt;p&gt;游乐园每天会开放多个游玩项目，每个项目的开放时间段和游玩所需时间（包括排队等待的时间）都不同。设游客游玩&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个项目，每个项目的游玩所需时间为&lt;script type=&quot;math/tex&quot;&gt;N_{p_i}&lt;/script&gt;，开放开始时间为&lt;script type=&quot;math/tex&quot;&gt;S_{p_i}&lt;/script&gt;，开放结束时间为&lt;script type=&quot;math/tex&quot;&gt;E_{p_i}&lt;/script&gt;，从项目&lt;script type=&quot;math/tex&quot;&gt;p_i&lt;/script&gt;移动到项目&lt;script type=&quot;math/tex&quot;&gt;p_j&lt;/script&gt;的路程所需时间为&lt;script type=&quot;math/tex&quot;&gt;T_{p_ip_j}&lt;/script&gt;，其中&lt;script type=&quot;math/tex&quot;&gt;p_i,p_j\in[1,2,\ldots,n]&lt;/script&gt;为游玩项目，&lt;script type=&quot;math/tex&quot;&gt;p_i=p_j=0&lt;/script&gt;为游乐园大门。要求规划一个项目游玩顺序，使得游客在规定开放时间段游玩所有项目，并且总游玩时间最短。即求下列问题：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{aligned}G(x) &amp;=g_1(x)+g_2(x)&amp;&amp;\ldots\ldots(1)\\g_{1}(x) &amp;=\sum_{j=1}^nT_{p_{j-1}p_{j}} &amp;&amp;\ldots\ldots(2)\\ g_{2}(x) &amp;=\sum_{j=1}^n\max (S_{p_{j}}-A_{p_{j}},0)&amp;&amp;\ldots\ldots(3)\end{aligned} %]]&gt;&lt;/script&gt;

&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;为一个从游乐园大门开始的项目序列&lt;script type=&quot;math/tex&quot;&gt;x=(p_0,p_1,\ldots,p_n)&lt;/script&gt; ，&lt;script type=&quot;math/tex&quot;&gt;A_{p_j}&lt;/script&gt;为游客真实到达项目&lt;script type=&quot;math/tex&quot;&gt;p_j&lt;/script&gt;的时间。&lt;script type=&quot;math/tex&quot;&gt;(2)&lt;/script&gt;式表示在项目序列&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;下路程所需的总时间，&lt;script type=&quot;math/tex&quot;&gt;(3)&lt;/script&gt;式表示在项目序列&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;下的总等待时间&lt;script type=&quot;math/tex&quot;&gt;^1&lt;/script&gt; ，&lt;script type=&quot;math/tex&quot;&gt;(1)&lt;/script&gt;式为路程和等待的总时间。由于游玩所需的时间固定不变，所以在这个问题中只需要考虑最小化&lt;script type=&quot;math/tex&quot;&gt;(1)&lt;/script&gt;式即可，目标函数如下：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{aligned}&amp;\min G(x)&amp;&amp;&amp;&amp;&amp;&amp;\ldots\ldots(4)\end{aligned} %]]&gt;&lt;/script&gt;

&lt;blockquote&gt;
  &lt;p&gt;注1：这里的等待时间并非排队等待时间，而是指游客到达了项目位置，而项目还没到开放开始时间，从而产生的等待时间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;问题分解&quot;&gt;问题分解&lt;/h3&gt;

&lt;p&gt;该问题可以看作一个基础问题附加上一定约束条件。其中基础问题为在完全图中给定一个起点，求一条最短通路，约束条件即为访问点的时间必须在规定范围之内。首先对于基础问题的求解十分简单，可以使用&lt;strong&gt;贪心算法&lt;/strong&gt;每次向离当前点最近的点前进（先不急反驳）。该过程可以使用伪码描述如算法1所示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;算法1：使用贪心算法求解基础问题 

输入：T (每条道路所需的时间)
	 N (游玩项目总数)
输出：X (最优游玩序列)

 1: U ← {1,...,n}
 2: X ← ∅
 3: i ← 0
 4: for 1 to N do
 5:     for j in U do
 6:         m ← min(T[i][j],T[i][m])
 7:     end for
 8:     X ← X ∪ m
 9:	    i ← m
10: end for
11: return X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基础问题得到了最快的路径，它并不一定能满足时间段要求。但给出了一个启示，即每次寻找的点应为满足时间段要求的最近点。由于满足时间段要求是根据每次选择动态变化的，没有办法一开始就知道选择这个点是否可行，此时我们可以用到&lt;strong&gt;回溯算法&lt;/strong&gt;。核心思想为每次选择的时候将临近点按照&lt;script type=&quot;math/tex&quot;&gt;(1)&lt;/script&gt;式规定的总时间逆序排序，首先选择最近的点开始下一次选择，直到发生时间冲突，回溯到上一次选择中，选择次近的点继续选择，一直循环直到找到一条满足时间段要求的通路，该过程可使用如算法2描述的伪代码实现。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;算法2：使用回溯算法求解带时间段条件的路径规划问题

输入：T (每条道路所需的时间)
	 N (游玩项目总数)
输出：X (最优游玩序列)

 1: U ← {1,...,n}
 2: i ← 0
 3: A[i] ← 0
 4: X ← reverse(recall(i,U))
 5: return X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;算法3：recall 使用回溯算法求解带时间段条件的路径规划问题中的递归函数

输入：i (当前访问的项目下标)
	 U (未访问序列)
输出：c (是否发生冲突)
     X (当前递归排序完毕的项目序列)

 1: c ← False
 2: X ← ∅
 3: if is_conflict then
 4:     return True,∅
 5: U ← time_sort(U)
 6: for j in U do
 7:     A[j] ← compute_arrive_time(i,j)
 8:     U ← U - j
 9:     c,X ← recall(j,U)
10:     if not c then
11:         break
12:     end if
13:     U ← U + j
14: end for
15: if c then
16:     return True,∅
17: end if
18: X ← X ∪ i
19: return Flase,X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;经计算，时间复杂度最好为&lt;script type=&quot;math/tex&quot;&gt;O(n^3)&lt;/script&gt;，最差为&lt;script type=&quot;math/tex&quot;&gt;O(n^{n+2})&lt;/script&gt;，平均为&lt;script type=&quot;math/tex&quot;&gt;O(n^{\frac{n}{2} + 2})&lt;/script&gt;。&lt;/p&gt;

&lt;h3 id=&quot;优化&quot;&gt;优化&lt;/h3&gt;

&lt;p&gt;回溯算法解决该问题有两个很大的缺点，其一是每次都要从整个未访问的点中求解，其中很多点是明显不能优先访问的，其二是冲突的反应太慢，直到剩下的所有点都不能走的时候才发现冲突，此时可能需要回溯很多次才能找到错误的根源。因此，提出一个按优先级排序的快冲突响应算法（PSFCR）。&lt;/p&gt;

&lt;p&gt;PSFCR算法核心思路是在每次递归计算前建立节点之间的支配关系，将非支配的点参与计算。此处的支配关系&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;支配&lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;表示，如果&lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;在&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;之前访问，&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;就无法满足时间段要求。而且在计算支配关系的时候，若发现&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;互相支配，则证明当前选择的节点无论怎么继续走都会发生冲突，即找到了一种可以只需要试探一次就能发现冲突的快冲突响应方法，PSFCR算法可以使用伪码描述为算法4。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;算法4：PSFCR 按优先级排序的快冲突响应算法

输入：T (每条道路所需的时间)
	 N (游玩项目总数)
输出：X (最优游玩序列)

 1: U ← {1,...,n}
 2: i ← 0
 3: A[i] ← 0
 4: c,F ← non_domination_sort(i,U)
 5: if c then
 6:     return ∅
 4: X ← reverse(PSFCR_recall(i,U,F))
 5: return X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;算法5：non_domination_sort 非支配排序算法

输入：i (当前访问的项目下标)
	 U (未访问序列)
输出：c (是否发生冲突)
     F (非支配的项目序列)
 
 1: F ← ∅
 2: d ← {0,...,0}
 3: for i in range(0,len(U))
 4:     for j in range(i+1,len(U))
 5:         if i ≺ j then // means i dominate j
 6:             d[i]++
 7:         elseif j ≺ i then
 8:		        d[j]++
 9:         end if
10:         if i ≺ j and j ≺ i then
11:             return True,∅
12:         end if
13:		end for
14: end for
15: for i in U
16:     if d[i]=0 then
17:		    F ← F ∪ i
18: F ← time_sort(F)
19: return False,F
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;算法6：PSFCR_recall PSFCR中的递归函数

输入：i (当前访问的项目下标)
	 U (未访问序列)
	 F (非支配的项目序列)
输出：c (是否发生冲突)
     X (当前递归排序完毕的项目序列)

 1: c ← False
 2: X ← ∅
 3: if F=∅ and U≠∅ then
 4:     return True,∅
 5: for j in U do
 6:     A[j] ← compute_arrive_time(i,j)
 7:     c,F ← non_domination_sort(i,U)
 8:     if c then
 9:        continue
10:     end if
11:     U ← U - j
12:     c,X ← PSFCR_recall(j,U,F)
13:     if not c then
14:         break
15:     end if
16:     U ← U + j
17: end for
18: if c then
19:     return True,∅
20: end if
21: X ← X ∪ i
22: return Flase,X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;经计算，时间复杂度最好为&lt;script type=&quot;math/tex&quot;&gt;O(n^3)&lt;/script&gt;，最差为&lt;script type=&quot;math/tex&quot;&gt;O(n^3)&lt;/script&gt;，平均为&lt;script type=&quot;math/tex&quot;&gt;O(n^3)&lt;/script&gt;。&lt;/p&gt;

&lt;h3 id=&quot;进一步优化&quot;&gt;进一步优化&lt;/h3&gt;

&lt;p&gt;这里要推翻一下最开始的假设了。细心的朋友可能会发现我之前根本是在胡说八道，没错，基础问题用贪心算法求出来的解并不是最优解，只是一个比较好的可行解而已。具体如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/CRP-20190506/01.png&quot; alt=&quot;贪心失败&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个问题主要出在&lt;strong&gt;区域选择&lt;/strong&gt;上，贪心算法有可能会先走到一个游玩项目比较偏远的区域，导致回到其他区域时花费异常大的时间。如果还要按照之前的方法，就需要穷举出所有的可行解。当然因为需要所有可行解，那么每个节点的排序操作就可以省略了，经计算无PSFCR时间复杂度为&lt;script type=&quot;math/tex&quot;&gt;O(n^n)&lt;/script&gt;，有PSFCR时间复杂度为&lt;script type=&quot;math/tex&quot;&gt;O(n^3l)&lt;/script&gt;，其中&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;为结点个数，&lt;script type=&quot;math/tex&quot;&gt;l&lt;/script&gt;为可行解数目。当&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
l&lt;(n-2)! %]]&gt;&lt;/script&gt;时，有PSFCR的方法更优。即，可行解越少（约束越强）PSFCR算法越好。&lt;/p&gt;

&lt;p&gt;这样确实可以求出最优解，但是在可行解偏多的情况下速度很不理想。由于其本身是一个NP问题，故应该找到一个符合时间约束的较优解即可。使用贪心算法的PSFCR就给出了一个较优解，再次基础之上，添加&lt;strong&gt;区域选择算法&lt;/strong&gt;（AS），使算法获得更为优秀的可行解。要进行区域选择，首先要进行&lt;strong&gt;区域划分&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;区域划分&quot;&gt;区域划分&lt;/h4&gt;

&lt;p&gt;假设线段&lt;script type=&quot;math/tex&quot;&gt;AB&lt;/script&gt;长度等于线段&lt;script type=&quot;math/tex&quot;&gt;AC&lt;/script&gt;长度，&lt;script type=&quot;math/tex&quot;&gt;\angle A&lt;/script&gt;小于60°时，&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
CB&lt;AB=AC %]]&gt;&lt;/script&gt;，而&lt;script type=&quot;math/tex&quot;&gt;\angle A&lt;/script&gt;大于60°时，&lt;script type=&quot;math/tex&quot;&gt;CB&gt;AB=AC&lt;/script&gt;。故使用60°作为一个分界值。假设当前所在点为点&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;，任意点&lt;script type=&quot;math/tex&quot;&gt;X\in\{A_1\}&lt;/script&gt;与&lt;script type=&quot;math/tex&quot;&gt;Y\in \{A_2\}&lt;/script&gt;，使得&lt;script type=&quot;math/tex&quot;&gt;\angle XAY &gt; 60°&lt;/script&gt;，即&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\frac{XA\cdot YA}{\lvert XA\rvert\lvert YA\rvert}&lt;\cos 60°=\frac{1}{2} %]]&gt;&lt;/script&gt;，则&lt;script type=&quot;math/tex&quot;&gt;A_1&lt;/script&gt;与&lt;script type=&quot;math/tex&quot;&gt;A_2&lt;/script&gt;属于不同的区域，反之属于相同区域。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/CRP-20190506/02.png&quot; alt=&quot;60°区域划分&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;区域选择&quot;&gt;区域选择&lt;/h4&gt;

&lt;p&gt;如果还是需要求出最优解，在划分区域后，可以将PSFCR的支配解按照区域分成一个二维数组。一个区域间算出可行解后，即可跳过整个区间，到下一个区间进行搜索。此时PSFCR-AS的时间复杂度为&lt;script type=&quot;math/tex&quot;&gt;O(n^3a)&lt;/script&gt;，其中&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;为总区域数，并有&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
a&lt;&lt;l %]]&gt;&lt;/script&gt;。由此可见区域划分极大提升了算法效率。&lt;/p&gt;

&lt;p&gt;但由于该算法用于一个即时交互系统，只需要求出一个较优解即可。为了使得时间复杂度变为&lt;script type=&quot;math/tex&quot;&gt;O(n^3)&lt;/script&gt;，就需要人为决定区域之间的访问顺序。目前可以根据&lt;strong&gt;平均距离&lt;/strong&gt;或&lt;strong&gt;最远距离&lt;/strong&gt;来判断访问顺序。为了减少回头路的长度，应该优先选择距离较近的区域访问。但平均距离和最远距离都只能解决部分情况，依概率，平均距离可以解决的情况更多。故我们选择先访问平均距离最短的区域。该算法只能求出较优解，伪码如下。&lt;/p&gt;

&lt;p&gt;[PSFCR-AS/AD伪码]&lt;/p&gt;
</description>
        <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2019/05/06/CRP/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/06/CRP/</guid>
        
        <category>Algorithm</category>
        
        
      </item>
    
      <item>
        <title>NSGA-II</title>
        <description>&lt;h2 id=&quot;首先&quot;&gt;首先&lt;/h2&gt;

&lt;p&gt;这两周其实都在为实现 &lt;strong&gt;GP-MILP-LS&lt;/strong&gt; 而抓脑袋。但他涉及到太多我不懂的知识了，一时半会是无法实现了。不能吊死在这个问题上，所以之后的一段时间还是会回归抠图问题的学习上。 &lt;br /&gt;
&lt;strong&gt;GP-MILP-LS&lt;/strong&gt; 中涉及到了很多经典的方法，比如 &lt;strong&gt;NSGA-II&lt;/strong&gt;。所以先实现一下经典算法，等基础厚实一点再去合成。&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;遗传算法&quot;&gt;遗传算法&lt;/h2&gt;

&lt;p&gt;首先要介绍的就是「&lt;strong&gt;遗传算法&lt;/strong&gt;」(&lt;strong&gt;Genetic Algoritm&lt;/strong&gt;)，简称&lt;code class=&quot;highlighter-rouge&quot;&gt;GA&lt;/code&gt;。&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;nsga-ii-大致思路&quot;&gt;NSGA-II 大致思路&lt;/h2&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;非支配排序&quot;&gt;非支配排序&lt;/h2&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;拥挤排序&quot;&gt;拥挤排序&lt;/h2&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
</description>
        <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2019/05/01/NSGA-II/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/01/NSGA-II/</guid>
        
        <category>GA</category>
        
        <category>MOP</category>
        
        <category>Reading</category>
        
        
      </item>
    
      <item>
        <title>Thoughts on PDMS</title>
        <description>&lt;h2 id=&quot;首先&quot;&gt;首先&lt;/h2&gt;

&lt;p&gt;虽然现在为读不懂另一篇论文而急得抓耳挠腮，但如果再不把对&lt;a href=&quot;/2019/04/11/PDMS4IM/&quot;&gt;上一篇&lt;/a&gt;的思考记下来我就忘掉了啊！&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;最终产物&quot;&gt;最终产物&lt;/h2&gt;

&lt;p&gt;在前文中介绍了，Image Matting(抠图)的最终产物是「&lt;strong&gt;Alpha mattes&lt;/strong&gt;」而不是一张抠出来的彩色前景图。因为Image Matting关心的并不是得到图片，而是得到&lt;strong&gt;前景和背景的关系&lt;/strong&gt;，也就是每个像素中&lt;strong&gt;前景颜色&lt;/strong&gt;所占比例，即「&lt;strong&gt;透明度&lt;/strong&gt;」。&lt;br /&gt;
&lt;br /&gt;
不知道有没有和我一样喜欢数码绘的朋友发现了一个问题，在不同混合模式下，每个颜色通道的混合比例是不同的。而我们再重新看到公式一:&lt;br /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;I_{i} = \alpha F_{i} + (1-\alpha) B_{i}&lt;/script&gt;

&lt;p&gt;这里的 \(\alpha\) 可是一个&lt;strong&gt;标量&lt;/strong&gt;啊！多个通道使用了同一个  \(\alpha\) ，这样抠出来的图怎么能行呢？而且我只得到了一个透明度贴图(Alpha mattes)啊，直接进行混合的话，怎么可能把原图抠出来呢？(哈哈，听不懂我在说什么吧，我也听不懂，我们看图说话吧！)&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;问题一难道-alpha-不应该是个矢量吗&quot;&gt;问题一：难道 \(\alpha\) 不应该是个矢量吗？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ToPSMS-20190421/00.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，在不同的混合模式下(上为Darken，下为Mutiply)，中间的混合区域颜色是不同的，也就是说，每个颜色通道的混合比例是不同的，对于每个颜色通道，应该有一个自己的 \(\alpha\) ，所以 \(\alpha\) 难道不应该是&lt;strong&gt;矢量&lt;/strong&gt;吗？&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;问题二我有一个-alpha-mattes-了我怎么得到前景图呢&quot;&gt;问题二：我有一个 Alpha mattes 了，我怎么得到前景图呢？&lt;/h3&gt;

&lt;p&gt;比如我现在想要把如下图中的红色圆给抠出来
&lt;img src=&quot;/img/in-post/ToPSMS-20190421/01.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过计算我得到了一个Alpha mattes如下
&lt;img src=&quot;/img/in-post/ToPSMS-20190421/02.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将两者按照透明度混合的话，我将得到如下的图
&lt;img src=&quot;/img/in-post/ToPSMS-20190421/03.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;啥？？？我要的才不是这个，中间的紫色是怎么回事？完全没有把蓝色通道给去掉啊！所以其实还是问题一， \(\alpha\) 真的不应该是一个标量吗？要得到的图其实应该是如下图的(咦，这不是Foreo Luna吗？)
&lt;img src=&quot;/img/in-post/ToPSMS-20190421/04.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;解答&quot;&gt;解答&lt;/h3&gt;

&lt;p&gt;嗯，其实最终还是我错了，问了师兄才知道，是我领域没搞清楚。Image Matting要解决的问题只有一个，那就是「&lt;strong&gt;前景占整个图片的透明度&lt;/strong&gt;」。而生产以上的图片，是「图像合成」领域要解决的事情。就拿上面的例子来说，如果要抠出最后的那张图，所要的输入不只是「Alpha mattes」还有一个很重要的就是在「Sample Pair Selection」中取样得到的「&lt;strong&gt;前景色&lt;/strong&gt;」。两者混合就可以得到了，同理每个通道的考虑也应该是「图像合成」要做的事。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Image matting refers to the soft extraction of foreground objects from a color image by estimating the opacity of each pixel.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我觉得……我确实有点太跳跃了，应该完善一下基础才行。&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;公式二&quot;&gt;公式二&lt;/h2&gt;

&lt;p&gt;公式二的推导费了我很大功夫，有一个主要原因是论文中的公式二居然，写！错！了！&lt;br /&gt;
写成了&lt;script type=&quot;math/tex&quot;&gt;\hat{\alpha}=\frac{(I-B) \cdot(F-B)}{\left(\|F-B\|_{2}\right)}&lt;/script&gt;，而正确的应该是&lt;script type=&quot;math/tex&quot;&gt;\hat{\alpha}=\frac{(I-B) \cdot(F-B)}{\left(\|F-B\|_{2}\right)^{2}}&lt;/script&gt;，分母少了个平方啊！&lt;br /&gt;
但我认为这里的推导还是有东西讲的，其实公式二是由上面的公式一推导而来的，而且它计算的是一个「&lt;strong&gt;理想情况&lt;/strong&gt;」，这一点非常关键！由公式一很好推出一个结论：&lt;br /&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{aligned}
I &amp;= \alpha F + (1-\alpha) B \\
I-B &amp;= \alpha (F-B) \\
\alpha &amp;= \frac{\left\|I-B\right\|_{2}}{\left\|F-B\right\|_{2}}
\end{aligned} %]]&gt;&lt;/script&gt;

&lt;p&gt;但这是有条件的，即向量I-B和向量F-B是「&lt;strong&gt;共线&lt;/strong&gt;」的即B、I、F共线，这就是刚刚说的「&lt;strong&gt;理想情况&lt;/strong&gt;」，而一般情况下，是不会共线的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ToPSMS-20190421/05.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以对于一般情况，我们就的计算 I 在 BF 上的「&lt;strong&gt;投影&lt;/strong&gt;」I’ 了，这样就推出公式二了&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{aligned}
\hat{\alpha} &amp;= \frac{\left\|I'-B\right\|_{2}}{\left\|F-B\right\|_{2}} \\
\hat{\alpha} &amp;= \frac{\left\|I-B\right\|_{2} \times\cos\theta }{\left\|F-B\right\|_{2}} \\
\hat{\alpha} &amp;= \frac{\frac{(I-B) \cdot(F-B)}{\left\|F-B\right\|_{2}}}{\left\|F-B\right\|_{2}} \\
\hat{\alpha} &amp;= \frac{(I-B) \cdot(F-B)}{\left(\|F-B\|_{2}\right)^{2}}
\end{aligned} %]]&gt;&lt;/script&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;评价函数&quot;&gt;评价函数&lt;/h2&gt;

&lt;p&gt;这里所说的评价函数是指对于颜色评价函数，其实之前不能理解就是因为没能理解到上面所说的「理想情况」。其实「理想情况」就是&lt;strong&gt;样本选取正确&lt;/strong&gt;的情况，共线时的误差为零。而 I 离得越远，和计算出来的 I’ 的误差就越大，复原的颜色误差就越大。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;O_{z}^{(c)}\left(x_{F}, x_{B}\right)=\exp \left(-\| C_{z}-\left(\hat{\alpha}_{z} C_{x_{P}}+\left(1-\hat{\alpha}_{z}\right) C_{x_{B}}\right)\right)\left\|_{2}\right)&lt;/script&gt;

&lt;p&gt;这里还有一个问题就是这个评价函数为什么不作为多目标计算时候的目标函数呢？那样在多目标选取的时候就已经可以排除掉不佳的答案了，是因为计算量太大了吗？&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;fdmo&quot;&gt;FDMO&lt;/h2&gt;

&lt;p&gt;在FDMO中，每次迭代如果找到了一个支配当前解的情况，就要和当前解交换，然后从头开始这次迭代。在某种情况下会重复很多次没必要的计算。我认为最差情况下每次迭代的最坏结果达到了\(O(n^2)\)，而不是文中所写的\(O(2(n-1-i)\)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/ToPSMS-20190421/06.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中 a &amp;gt; b 是 a Pareto Dominate b的意思。&lt;br /&gt;
而且如果其他剩余的元素(空心圆)也是形如这样，结构递归下去的话，最差的总时间复杂度达到了\(O(2^n)\)！当然这个情况在宇宙毁灭前都不一定能随机到。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{aligned}
&amp;(\frac{n}{2^1})^2+(\frac{n}{2^2})^2+(\frac{n}{2^3})^2+\ldots+(\frac{n}{2^{log(n)}})^2\\
&amp;= 1^2 + 2^2 + 4^2 + 8^2 + \ldots + (\frac{n}{2})^2\\
&amp;= 4^0 + 4^1 + 4^2 + 4^3 + \ldots + 4^{log(n)-1}\\
&amp;= \frac{4^{log(n)-1}-1}{3}\\
&amp;= O(4^{logn(n)})\\
&amp;= O(2^n)\\
\end{aligned} %]]&gt;&lt;/script&gt;

&lt;p&gt;所以我稍微改了一下程序，只要不要走那么多次回头路就可以了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;i ← 1
j ← the number of elements in array C
while j &amp;lt;= j do
    cmp ← i + 1
    exchanged ← False
    while cmp &amp;lt;= j do
        if C[i] dominate C[cmp] then
            swap(C[cmp], C[j])
            j ← j - 1
        else if C[cmp] dominate C[i] then
            swap(C[i], C[cmp])
            swap(C[cmp], C[j])
            j ← j - 1
            cmp ← cmp + 1     // 继续走到底，交换到最优的解
            exchanged ← true  // 交换了表示要重走一次
        else
            cmp ← cmp + 1
        end if

        if cmp = j and exchanged then  // 如果到了最后看情况是否需要重复
            cmp ← i + 1
            exchanged ← False
        end if
    end while
    i ← i + 1
end while
return C, i
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;如果还有什么想到的新问题，或者有误的地方会及时改正！先告一段落吧，有时间把问题模型整理一下，现在最主要的任务是解决问题模型呢。&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2019/04/21/ToPDMS/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/21/ToPDMS/</guid>
        
        <category>CV</category>
        
        <category>MOP</category>
        
        <category>Reading</category>
        
        
      </item>
    
      <item>
        <title>PDMS for Image Matting</title>
        <description>&lt;h2 id=&quot;首先&quot;&gt;首先&lt;/h2&gt;

&lt;p&gt;终于完整地读完第一篇论文了！&lt;br /&gt;师兄关于抠图的论文《&lt;a href=&quot;https://ieeexplore.ieee.org/document/8660585&quot;&gt;Pixel-level Discrete Multiobjective Sampling for Image Matting&lt;/a&gt;》。&lt;br /&gt;师兄超Nice的，被无知的我穷追不舍（师兄好可怜），但我还是只能稍作了解。&lt;br /&gt;现记录如下，有理解错误和不足的地方会及时改正。:)&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;关于抠图&quot;&gt;关于抠图&lt;/h2&gt;

&lt;p&gt;「&lt;strong&gt;抠图&lt;/strong&gt;」的主要任务很简单，就是从一张图片中，把你需要的物体(前景)从图像中提取出来。其操作是通过评估每个像素点的透明度来完成的。&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Image matting refers to the soft extraction of foreground objects from a color image by estimating the opacity of
each pixel.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;抠图方法&quot;&gt;抠图方法&lt;/h2&gt;

&lt;h3 id=&quot;一个重要公式&quot;&gt;一个重要公式&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;I_{i} = \alpha F_{i} + (1-\alpha) B_{i}&lt;/script&gt;

&lt;blockquote&gt;
  &lt;p&gt;I 为该像素由我们肉眼观察到的颜色 &lt;br /&gt;
F 为该像素对应的前景的颜色 &lt;br /&gt;
B 为该像素对应的背景的颜色 &lt;br /&gt;
i 表示通道，比如在RGB色域中就是R G B三个通道啦 &lt;br /&gt;
&lt;br /&gt;
其实就是一个颜色叠加，用 α 和 1-α 来表示前景/背景的透明度 &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;抠图所需内容&quot;&gt;抠图所需内容&lt;/h3&gt;

&lt;p&gt;所需内容有 2 张图片：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;一张待抠图片（当然）&lt;/li&gt;
  &lt;li&gt;一张大致确定前景/背景位置的图片（Trimap or Scribble）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;trimap--scribble&quot;&gt;Trimap &amp;amp; Scribble&lt;/h4&gt;

&lt;p&gt;对于第 2 个，可能会比较陌生，但看下图就好理解了。其实就是一个用来划分区域的「&lt;strong&gt;三色图&lt;/strong&gt;」。&lt;br /&gt;
「&lt;strong&gt;黑色区域&lt;/strong&gt;」表示确定为「&lt;strong&gt;背景&lt;/strong&gt;」的区域；&lt;br /&gt;
「&lt;strong&gt;白色区域&lt;/strong&gt;」表示确定为「&lt;strong&gt;前景&lt;/strong&gt;」的区域；&lt;br /&gt;
「&lt;strong&gt;灰色区域&lt;/strong&gt;」表示「&lt;strong&gt;不确定&lt;/strong&gt;」的区域。&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;而抠图算法的最终目的，就是消除这个不确定的区域。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有「&lt;strong&gt;trimap&lt;/strong&gt;」和「&lt;strong&gt;scribble&lt;/strong&gt;」两种，trimap 比较精准，而 scribble 就是用户手画的随便指定了一下前景和背景区域。&lt;br /&gt;
当然后者更便于用户使用，但确定的区域少了，难度也随之增加了。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/PDMS4IM-20190411/01.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;抠图的产物&quot;&gt;抠图的产物&lt;/h3&gt;

&lt;p&gt;&lt;del&gt;这还用说吗！当然是抠出来的图啊！&lt;/del&gt;&lt;br /&gt;
&lt;strong&gt;注意了（敲黑板）&lt;/strong&gt;！这里可能会有人和我一样进入一个误区，认为抠图的最终产物是一张前景图。&lt;br /&gt;
其实不是的，抠图的产物是一个叫做「&lt;strong&gt;Alpha mattes&lt;/strong&gt;」的东西，如下图所示。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/PDMS4IM-20190411/02.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就是一个蒙版，每个像素的灰度值代表透明度。&lt;br /&gt;
「&lt;strong&gt;黑色&lt;/strong&gt;」代表该像素透明度为 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;；&lt;br /&gt;
「&lt;strong&gt;白色&lt;/strong&gt;」代卖该像素透明度为 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;；&lt;br /&gt;
「&lt;strong&gt;灰色&lt;/strong&gt;」按照灰度确定该像素的透明度。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;有了这个 Alpha mattes 我们就已经把前景给提取出来了。&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;至于所说的前景图，师兄说那是「图像合成」的事了。&lt;br /&gt;
而且，如果用于图像合成的话，不仅仅需要生成一个 Alpha mattes 还需要一个「F」，即一个前景色的图！&lt;br /&gt;
&lt;br /&gt;
为什么呢？我放在最后「思考」中介绍吧，一直扩展还下不下课了！喂喂！&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;现有方法&quot;&gt;现有方法&lt;/h3&gt;

&lt;p&gt;现主要抠图算法都基于以下 3 种方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基于采样算法 Sampling-Based&lt;/li&gt;
  &lt;li&gt;基于遗传算法 Propagation-Based&lt;/li&gt;
  &lt;li&gt;以上两者混合 Hybrid Methods&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该论文的做法是基于采样的，所以比较详细说明了采样。&lt;br /&gt;
其他两种我的脑子告诉我它不会，等我喂饱它之后再来补充。&lt;/p&gt;

&lt;h3 id=&quot;基于采样方法&quot;&gt;基于采样方法&lt;/h3&gt;

&lt;p&gt;基于采样的方法又分为了「&lt;strong&gt;参数型 Parametric&lt;/strong&gt;」和「&lt;strong&gt;无参型 Non-Parametric&lt;/strong&gt;」两种。&lt;br /&gt;
先说结论，该论文用的是「无参型」。&lt;/p&gt;

&lt;h4 id=&quot;parametric&quot;&gt;Parametric&lt;/h4&gt;

&lt;p&gt;和该论文实现无关，贴上原文观摩观摩就好啦。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;In parametric methods, pixel colors are assumed to obey a specific distribution, and the distribution parameters are estimated from the pixels in known regions. Alpha values are estimated according to the distance between the color of the unknown pixel and the color distribution of known regions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;non-parametric&quot;&gt;Non-Parametric&lt;/h4&gt;

&lt;p&gt;这方法就是说呢，从之前的「Trimap」或「Scribble」里得到已知的「前景区域」和「背景区域」。&lt;br /&gt;
对于某一未知区域的像素点，从以上两个确定区域中选取一对像素作为样本，即得到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; ，再加上该未知区域像素的 &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; 就可以通过上面的「重要公式」求出 &lt;code class=&quot;highlighter-rouge&quot;&gt;α&lt;/code&gt; 了。&lt;br /&gt;
最后判断这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;α&lt;/code&gt; 是否符合标准就好（什么标准啊，你话不要说一半啊！）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In non-parametric methods, foreground and background color samples are obtained from known regions, whereby an objective function is used to find an optimal pair of foreground and background samples.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;计算-α-的公式&quot;&gt;计算 α 的公式&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{\alpha}=\frac{(I-B) \cdot(F-B)}{\left(\|F-B\|_{2}\right)^{2}}&lt;/script&gt;

&lt;p&gt;该公式是由以上「重要公式」推导出来的，有多个颜色通道，所以这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 均为向量。&lt;br /&gt;
其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;‖*‖₂&lt;/code&gt; 为&lt;a href=&quot;https://en.wikipedia.org/wiki/Norm_(mathematics)#Euclidean_norm&quot;&gt;欧几里德范数&lt;/a&gt;，在这里就和「模」差不多。&lt;br /&gt;
&lt;br /&gt;
推导过程在「思考」部分，这里和后面的内容有关联，是我之前困惑的地方，所以想着重说明一下。&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;流程&quot;&gt;流程&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/PDMS4IM-20190411/03.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Pre-Processing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;预处理阶段，主要是通过一些算法来缩小「Trimap」或「Scribble」中「未知区域」的空间，减少之后的计算量。比如使用一些颜色相近和空间相近原则，来扩张已确定的「前景区域」和「背景区域」。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Color Sampling&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前景色和背景色的取样阶段。第二个公式中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 并不是大海捞针，每一个都测试一遍的。而是从一堆可行解里面选择，这堆可行解就是通过「Color Sampling」过程筛选出来的。&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这个阶段就是本文重点优化的阶段。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3. Sample Pair Selection&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从上一个步骤中根据目标函数选取最佳的样本，也就是公式中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Solving Alpha&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将上一步得到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 带入第二个公式求出 &lt;code class=&quot;highlighter-rouge&quot;&gt;α&lt;/code&gt; ，从而得到「Alpha mattes」。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. Post-Processing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;后处理阶段，通过一些算法使得「Alpha mattes」的图像更加平滑。&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;现有方法的不足之处&quot;&gt;现有方法的不足之处&lt;/h2&gt;

&lt;p&gt;不足之处主要在于「Color Sampling」阶段。如上面所说抠图主要运用「第二个公式」的 &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 求出 &lt;code class=&quot;highlighter-rouge&quot;&gt;α&lt;/code&gt; 进而得到最终产物「Alpha mattes」，&lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 都要从候选样本中选取，所以该阶段是整个抠图过程的关键。&lt;/p&gt;

&lt;h3 id=&quot;color-sampling-的困难点&quot;&gt;Color Sampling 的困难点&lt;/h3&gt;

&lt;p&gt;「Color Sampling」阶段的困难主要在于两点，「&lt;strong&gt;取样标准选取&lt;/strong&gt;」和「&lt;strong&gt;取样集合太大&lt;/strong&gt;」的问题。&lt;/p&gt;

&lt;h3 id=&quot;已有的解决方法&quot;&gt;已有的解决方法&lt;/h3&gt;

&lt;p&gt;对于「取样标准选取」的解决方法，最早提出的是一种「基于距离的取样方法」，即样本应该离未知点越近越好，这样的话选取的样本一般都集中在未知点到已知区域的边界处。但是很遗憾，通常正确的样本并不一定离未知点很近，所以需要多种标准来选择，比如「&lt;strong&gt;距离&lt;/strong&gt;」、「&lt;strong&gt;颜色&lt;/strong&gt;」、「&lt;strong&gt;纹理&lt;/strong&gt;」等。所以提出了「&lt;strong&gt;基于多种标准的取样方法&lt;/strong&gt;」&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;对于「取样集合太大」的解决方法，通常采用叫做「&lt;a href=&quot;https://arxiv.org/abs/1612.01601&quot;&gt;Superpixels&lt;/a&gt;」的方法。简单来说就是把很多颜色相近的像素点聚集起来成为一个「超像素」，这个「超像素」中只有一个颜色，就是之前聚集的像素点的「&lt;strong&gt;颜色均值&lt;/strong&gt;」。这样就大大减少了取样集合的大小。&lt;/p&gt;

&lt;h3 id=&quot;不足之处&quot;&gt;不足之处&lt;/h3&gt;

&lt;p&gt;对于「基于多种标准的取样方法」来说，主要的问题在于「&lt;strong&gt;多种标准之间的冲突问题&lt;/strong&gt;」，如一个正确的样本，它的颜色和未知点很近，但是距离却和未知点很远，这样标准之间就产生了冲突，很可能将正确的点给抛弃掉。从而产生「&lt;strong&gt;丢失正确样本 Missing True Samples（MTS）&lt;/strong&gt;」的问题。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;For example, if true color samples sembled to the color of an unknown pixel are far from the unknown pixel, the spatial closeness criterion and color criterion will be in conflict. The true samples may not be collected by existing methods in this case, because the dissatisfaction of spatial closeness criterion may result in uncompetitive scores for the true samples in the comparison to that for the pixels closed to unknown pixels.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于「Superpixels」来说，也一样的，可能正确的样本颜色被均值化，从而产生「MTS」问题。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The mean color of a superpixel cannot represent the color outliers in the superpixel which may be the true color sample for alpha estimation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;改进方法&quot;&gt;改进方法&lt;/h2&gt;

&lt;p&gt;该论文提出的「&lt;strong&gt;Pixel-level Discrete Multiobjective Sampling（PDMS）&lt;/strong&gt;」算法主要就是为了避免「MTS」问题。&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;多目标优化&quot;&gt;多目标优化&lt;/h3&gt;

&lt;p&gt;对于「多种标准之间的冲突问题」，将其看做「&lt;strong&gt;多目标优化问题 Multiobjective Optimization Problem (MOP)&lt;/strong&gt;」，从而解决标准之间的冲突。目标函数如下：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{aligned} g_{1}(x) &amp;=\left\|C_{x}-C_{z}\right\|_{2} \\ g_{2}(x) &amp;=\left\|S_{x}-S_{z}\right\|_{2} \\ g_{3}(x) &amp;=\left\|T_{x}-T_{z}\right\|_{2} \end{aligned} %]]&gt;&lt;/script&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中\(g_{1}(x)\)、\(g_{2}(x)\)、\(g_{3}(x)\)为三个目标函数&lt;br /&gt;
\(x\)为已知区域中的某个点，\(z\)为当前计算的未知区域点&lt;br /&gt;
\(C\)为颜色向量、\(S\)为空间坐标向量、\(T\)为纹理特征向量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同时使所有目标函数最小化&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min g_{1}(x),\min g_{2}(x),\ldots,\min g_{n}(x)&lt;/script&gt;

&lt;p&gt;注意这里只是一个样本点的选取，在「Color Sampling」过程中是要选取 &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 两个样本点的，所以该问题其实是&lt;strong&gt;两个&lt;/strong&gt;「MOP」问题。&lt;/p&gt;

&lt;h3 id=&quot;pixel-level&quot;&gt;Pixel-Level&lt;/h3&gt;

&lt;p&gt;对于「Superpixels」的问题，想法很简单，既然均值化会丢失真实样本，那不均值化好了，直接从所有像素中取样，即「Pixel-Level」。但「取样集合太大」的问题不又回来了吗，进入死循环中。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;这个时候就需要跳出固定思维了，本文通过设计了一个新的算法「&lt;strong&gt;Fast Discrete Multiobjective Optimization（FDMO）&lt;/strong&gt;」从而避免了「取样集合太大」导致的「计算量过大问题」。&lt;/p&gt;

&lt;h4 id=&quot;fdmo&quot;&gt;FDMO&lt;/h4&gt;

&lt;p&gt;「FDMO」的主要优化依据在于，经过「MOP」筛选之后，候选样本集所在的「Pareto Optimal Solution」很小很小。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;168,409&lt;/code&gt; 个可行解中最后只有 &lt;code class=&quot;highlighter-rouge&quot;&gt;11&lt;/code&gt; 在「Pareto Set」中。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;For the foreground sampling MOP defined in Subsection III-A2, the universal set contains 168,409 feasible solutions while only 11 solutions are Pareto optimal in this case.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这样的情况下，算法的核心思想就是&lt;strong&gt;在每一趟遍历中，把所有该剔除（被支配）的样本给剔除掉&lt;/strong&gt;。这样如果最终「Pareto Optimal Solution」的大小为 &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;，就只需要在 &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; 趟遍历中完成算法。设取样集合总大小为 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; 则算法的时间复杂度为 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(kn)&lt;/code&gt; 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 *  Input: all possible values C.
 *  Output: C, i (the first i − 1 elements in array C are Pareto optimal)
 */
i ← 1
j ← the number of elements in array C
while i ≤ j do 
    cmp ← i + 1
    while cmp ≤ j do
        if C[i] dominate C[cmp] then
            swap(C[cmp], C[j])
            j ← j − 1
        else if C[cmp] dominate C[i] then
            swap(C[i], C[cmp])
            swap(C[cmp], C[j])
            j ← j − 1
            cmp ← i + 1
        else
            cmp ← cmp + 1
        end if
    end while
    i ← i + 1
end while
return C, i
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Best&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Worst&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Average&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;时间复杂度&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\(O(n)\)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\(O(n^2)\)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\(O(kn)\)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;空间复杂度&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\(O(n)\)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\(O(n)\)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;\(O(n)\)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;选取样本对的方法&quot;&gt;选取样本对的方法&lt;/h2&gt;

&lt;p&gt;也就是「Sample Pair Selection」阶段，在上一阶段中得到的候选样本里选取最佳样本。&lt;br /&gt;
其评价方程如下：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{aligned}
O_{z}\left(x_{F}, x_{B}\right)&amp;=O_{z}^{(c)}\left(x_{F}, x_{B}\right) \times O_{z}^{(s)}\left(x_{F}, x_{B}\right)
\\
\\
O_{z}^{(c)}\left(x_{F}, x_{B}\right)&amp;=\exp \left(-\| C_{z}-\left(\hat{\alpha}_{z} C_{x_{P}}+\left(1-\hat{\alpha}_{z}\right) C_{x_{B}}\right)\right)\left\|_{2}\right)
\\
O_{z}^{(s)}\left(x_{F}, x_{B}\right)&amp;=\exp \left(\frac{-\left\|S_{z}-S_{x_{F}}\right\|_{2}}{\frac{1}{\left|\Omega_{F}\right|} \sum_{x_{i} \in \Omega_{F}}\left\|S_{z}-S_{x_{i}}\right\|_{2}}\right) \times \exp \left(\frac{-\left\|S_{z}-S_{x_{B}}\right\|_{2}}{\frac{1}{\left|\Omega_{B}\right|} \sum_{x_{i} \in \Omega_{B}}\left\|S_{z}-S_{x_{i}}\right\|_{2}}\right)
\end{aligned} %]]&gt;&lt;/script&gt;

&lt;blockquote&gt;
  &lt;p&gt;是不是头都要炸了？哈哈哈&lt;br /&gt;
静下心来，其实很简单&lt;br /&gt;
第二个公式的意思就是用算出来的 alpha、B 和 F&lt;br /&gt;
反过来求 I’ ，看看这个 I’ 的颜色有多大变化，变化越小越好&lt;br /&gt;
第三个公式的意思就是 F 和 B 应该是所有样本里距离最近的&lt;br /&gt;
第一个公式就是这两者的叉乘，两者一起评估&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;结论--思考&quot;&gt;结论 &amp;amp; 思考&lt;/h2&gt;

&lt;p&gt;结论就是该算法最终在「&lt;strong&gt;很少的候选样本&lt;/strong&gt;」中达到了「&lt;strong&gt;很小的 Alpha 误差&lt;/strong&gt;」。&lt;br /&gt;
但是速度方面不尽人意，空间方面耗费很小。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;思考主要想说一下自己之前对「最终产物」的误解，以及「前景图」生成过程。&lt;br /&gt;
还有「第二个公式」的推导过程（因为论文中少了一个平方，困扰了我很久），以及选择样本对时「目标函数」的作用。
最后是「FDMO」算法在我想的一个特殊情况下时间复杂度达到了\(O(2^n)\)，以及我的改进方法。&lt;br /&gt;
由于篇幅太长了，我自己都不愿看了，这些内容就放到下一篇吧（让我偷个懒）。&lt;/p&gt;
</description>
        <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2019/04/11/PDMS4IM/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/11/PDMS4IM/</guid>
        
        <category>CV</category>
        
        <category>MOP</category>
        
        <category>Reading</category>
        
        
      </item>
    
      <item>
        <title>Hello World!</title>
        <description>&lt;h2 id=&quot;先说原因&quot;&gt;先说原因&lt;/h2&gt;
&lt;p&gt;最近总算是把考试给结束掉了，要开启新的学习篇章了，把学习的艰难过程做一个记录吧！&lt;br /&gt;
&lt;br /&gt;
这段时间面试备考，回顾了以前做过的项目和记录的学习笔记，感觉就是，“哇！我学了这么多东西吗！为什么没有好好地记录下来呢？”&lt;br /&gt;
&lt;br /&gt;
虽然很多过程看起来都很愚蠢，但都是成长的一部分啊，说不定还有其他的朋友和我一样往坑里跳！&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;再说内容&quot;&gt;再说内容&lt;/h2&gt;
&lt;p&gt;内容主要以我平时的学习记录为主，一些知识的总结，踩坑记录等等。&lt;br /&gt;
&lt;br /&gt;
有时间的话再聊聊一些生活上的事情，但多半我是懒得写的（笑）。&lt;/p&gt;

</description>
        <pubDate>Tue, 09 Apr 2019 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2019/04/09/Hello-World/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/09/Hello-World/</guid>
        
        <category>Life</category>
        
        
      </item>
    
  </channel>
</rss>
